{"version":3,"sources":["Utils & Objects/functions.js","Utils & Objects/sketch.js","Components/Maze.js","Utils & Objects/Cell.js","Components/App.js","index.js"],"names":["transformLocations","arr","i","length","parseInt","indexTrans","j","cols","sketch","p","lastPoint","startPoint","index","grid","size","mazeStart","execute","alg","map","q","cell","undefined","setup","createCanvas","parent","frameRate","myCustomRedrawAccordingToNewPropsHandler","props","makePath","path","crr","key","console","log","includes","push","isFree","getValue","bfs","shift","getX","getY","setValue","setVisited","next","dfs","pop","getVisited","neighbors","neighborR","neighborL","neighborD","neighborU","cellNeighbor","show","x","y","walls","value","visited","w","coord_x","Math","floor","coord_y","stroke","fill","rect","noFill","line","codedMaze","draw","a","background","getWalls","alert","Maze","className","id","dim","Cell","mazeValue","this","adjust","oldArr","val","App","identifySpecials","paramArr","entrance","state","text","exit","split","utils","setState","special","handleFile","file","fileReader","FileReader","readAsText","onloadend","e","content","target","result","rows","match","RegExp","addFile","preventDefault","tmpArr","isNaN","charAt","linetoArr","tmpMap","setWalls","calculateDims","sizeCell","algorithm","width","str","char_arr","type","accept","onChange","files","htmlFor","name","disabled","onClick","mazeGrid","actualMaze","React","Component","ReactDOM","render","StrictMode","document","getElementById"],"mappings":"gVAMO,SAASA,EAAmBC,GAC/B,IAAK,IAAIC,EAAI,EAAGA,EAAID,EAAIE,OAAQD,IAC5BD,EAAIC,GAAKE,SAASH,EAAIC,IACP,IAAXD,EAAIC,GACJD,EAAIC,GAAK,EAETD,EAAIC,GAAe,EAATD,EAAIC,GAAU,EAGhC,OAAOD,EAQJ,SAASI,EAAWH,EAAGI,EAAGC,GAC7B,OAAOL,EAAII,EAAKC,ECrBL,SAASC,EAAOC,GAC7B,IAGIF,EAKAG,EACAC,EAEAC,EAXAC,EAAO,KACPC,EAAO,KACPC,EAAY,GAEZC,GAAU,EACVC,EAAM,KAENC,EAAM,GAKNC,EAAI,GACJC,OAAOC,EAGXZ,EAAEa,MAAQ,WACOb,EAAEc,aAAa,IAAK,KAC1BC,OAAO,UAChBf,EAAEgB,UAAU,MAGdhB,EAAEiB,yCAA2C,SAACC,GA0E5C,SAASC,IAIP,IAHA,IAAIC,EAAO,GACPC,EAAMpB,EAEHoB,IAAQnB,GAEb,IAAK,IAAIoB,KADTC,QAAQC,IAAI,iBAAkBH,GACdZ,EACVA,EAAId,SAAS2B,IAAMG,SAASJ,KAC9BD,EAAKM,KAAKL,GACVA,EAAM1B,SAAS2B,IAIrB,OAAOF,EAOT,SAASO,EAAOlC,EAAGI,GACjB,SACGJ,GAAK,EACLA,EAAIW,EAAKV,OACTG,GAAK,EACLA,EAAIO,EAAKV,QACoC,IAA5CU,EAAKR,EAAWH,EAAGI,EAAGC,IAAO8B,WACgB,IAA5CxB,EAAKR,EAAWH,EAAGI,EAAGC,IAAO8B,aAWpC,SAASC,IAIP,GAHAlB,EAAOD,EAAEoB,QACT3B,EAAQP,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAQlC,GAEuB,IAAhEM,EAAKR,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAQlC,IAAO8B,WAEnD,OAAO,EAKT,GAFAnB,EAAIN,GAAS,GAEuD,IAAhEC,EAAKR,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAQlC,IAAO8B,WAGnD,OAFAL,QAAQC,IAAI,aACZvB,EAAYL,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAQlC,IAC1C,EAOT,GAJAM,EAAKR,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAQlC,IAAOmC,SAAS,GAC1D7B,EAAKR,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAQlC,IAAOoC,YAAW,IAGf,IAAzCP,EAAOhB,EAAKoB,OAAS,EAAGpB,EAAKqB,QAAkB,CACjD,IAAIG,EAAO/B,EAAKR,EAAWe,EAAKoB,OAAS,EAAGpB,EAAKqB,OAAQlC,IACzDW,EAAIN,GAAOuB,KAAK9B,EAAWe,EAAKoB,OAAS,EAAGpB,EAAKqB,OAAQlC,IACzDY,EAAEgB,KAAKS,GAGT,IAA6C,IAAzCR,EAAOhB,EAAKoB,OAAS,EAAGpB,EAAKqB,QAAkB,CACjD,IAAIG,EAAO/B,EAAKR,EAAWe,EAAKoB,OAAS,EAAGpB,EAAKqB,OAAQlC,IACzDW,EAAIN,GAAOuB,KAAK9B,EAAWe,EAAKoB,OAAS,EAAGpB,EAAKqB,OAAQlC,IACzDY,EAAEgB,KAAKS,GAGT,IAA6C,IAAzCR,EAAOhB,EAAKoB,OAAQpB,EAAKqB,OAAS,GAAa,CACjD,IAAIG,EAAO/B,EAAKR,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAS,EAAGlC,IACzDW,EAAIN,GAAOuB,KAAK9B,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAS,EAAGlC,IACzDY,EAAEgB,KAAKS,GAGT,IAA6C,IAAzCR,EAAOhB,EAAKoB,OAAQpB,EAAKqB,OAAS,GAAa,CACjD,IAAIG,EAAO/B,EAAKR,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAS,EAAGlC,IACzDW,EAAIN,GAAOuB,KAAK9B,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAS,EAAGlC,IACzDY,EAAEgB,KAAKS,GAGT,OAAO,EAOT,SAASC,IASP,GAPsE,IAAlEhC,EAAKR,EAAWU,EAAU,GAAIA,EAAU,GAAIR,IAAO8B,aACrDxB,EAAKR,EAAWU,EAAU,GAAIA,EAAU,GAAIR,IAAOmC,SAAS,GAC5D7B,EAAKR,EAAWU,EAAU,GAAIA,EAAU,GAAIR,IAAOoC,YAAW,IAGhEvB,EAAOD,EAAE2B,MAE2D,IAAhEjC,EAAKR,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAQlC,IAAO8B,WAInD,OAHAL,QAAQC,IAAI,aACZvB,EAAYL,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAQlC,GACjDI,EAAaN,EAAWU,EAAU,GAAIA,EAAU,GAAIR,IAC7C,EAITK,EAAQP,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAQlC,GAG7CyB,QAAQC,IAAId,GACZD,EAAIN,GAAS,GAEY,IAApBQ,EAAKiB,YAAqBjB,EAAK2B,eAClC3B,EAAKsB,SAAS,GACdtB,EAAKuB,YAAW,IAElB,IAAIK,EAAY,GAEhB,IAA6C,IAAzCZ,EAAOhB,EAAKoB,OAAS,EAAGpB,EAAKqB,QAAkB,CACjD,IAAIQ,EAAapC,EACfR,EAAWe,EAAKoB,OAAS,EAAGpB,EAAKqB,OAAQlC,IAE3CW,EAAIN,GAAOuB,KAAK9B,EAAWe,EAAKoB,OAAS,EAAGpB,EAAKqB,OAAQlC,IACzDyC,EAAUb,KAAKc,GAEjB,IAA6C,IAAzCb,EAAOhB,EAAKoB,OAAS,EAAGpB,EAAKqB,QAAkB,CACjD,IAAIS,EAAarC,EACfR,EAAWe,EAAKoB,OAAS,EAAGpB,EAAKqB,OAAQlC,IAE3CW,EAAIN,GAAOuB,KAAK9B,EAAWe,EAAKoB,OAAS,EAAGpB,EAAKqB,OAAQlC,IAEzDyC,EAAUb,KAAKe,GAEjB,IAA6C,IAAzCd,EAAOhB,EAAKoB,OAAQpB,EAAKqB,OAAS,GAAa,CACjD,IAAIU,EAAatC,EACfR,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAS,EAAGlC,IAE3CW,EAAIN,GAAOuB,KAAK9B,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAS,EAAGlC,IAEzDyC,EAAUb,KAAKgB,GAEjB,IAA6C,IAAzCf,EAAOhB,EAAKoB,OAAQpB,EAAKqB,OAAS,GAAa,CACjD,IAAIW,EAAYvC,EACdR,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAS,EAAGlC,IAE3CW,EAAIN,GAAOuB,KAAK9B,EAAWe,EAAKoB,OAAQpB,EAAKqB,OAAS,EAAGlC,IAEzDyC,EAAUb,KAAKiB,GAGjB,IAAK,IAAIlD,EAAI,EAAGA,EAAI8C,EAAU7C,OAAQD,IAAK,CACzC,IAAImD,EAAeL,EAAU9C,GAE3BmD,IACCA,EAAaN,cACc,IAA5BM,EAAahB,aAEbL,QAAQC,IAAIoB,GACZlC,EAAEgB,KAAKkB,IAGX,OAAO,EAYT,SAASC,EACPC,EACAC,GAKC,IAJDC,EAIA,uDAJQ,EAAC,GAAM,GAAM,GAAM,GAC3BC,EAGA,uCAFAC,EAEA,uCADA7C,EACA,uCACM8C,EAAI9C,EACN+C,EAAUC,KAAKC,OAAOR,EAAI,GAAKK,GAC/BI,EAAUF,KAAKC,OAAOP,EAAI,GAAKI,GAOnC,QANgB,IAAZD,IACFlD,EAAEwD,OAAO,IAAK,EAAG,IAAK,KACtBxD,EAAEyD,KAAK,IAAK,EAAG,IAAK,KACpBzD,EAAE0D,KAAKN,EAASG,EAASJ,EAAGA,GAC5BnD,EAAEwD,OAAO,IAAK,IAAK,MAEbP,GAEN,KAAK,EACHjD,EAAEwD,OAAO,IAAK,EAAG,KACjBxD,EAAEyD,KAAK,IAAK,EAAG,KACfzD,EAAE0D,KAAKN,EAASG,EAASJ,EAAGA,GAC5BnD,EAAEwD,OAAO,IAAK,IAAK,KACnB,MAEF,KAAK,EACHxD,EAAEwD,OAAO,GAAI,IAAK,IAClBxD,EAAEyD,KAAK,GAAI,IAAK,IAChBzD,EAAE0D,KAAKN,EAASG,EAASJ,EAAGA,GAC5BnD,EAAEwD,OAAO,IAAK,IAAK,KACnB,MACF,QACExD,EAAEwD,OAAO,IAAK,IAAK,KACnBxD,EAAE2D,SAIFX,EAAM,IAERhD,EAAE4D,KAAKR,EAASG,EAASH,EAAUD,EAAGI,GAGpCP,EAAM,IAERhD,EAAE4D,KAAKR,EAAUD,EAAGI,EAASH,EAAUD,EAAGI,EAAUJ,GAGlDH,EAAM,IAERhD,EAAE4D,KAAKR,EAASG,EAAUJ,EAAGC,EAAUD,EAAGI,EAAUJ,GAGlDH,EAAM,IAERhD,EAAE4D,KAAKR,EAASG,EAAUJ,EAAGC,EAASG,GA9StCrC,EAAM2C,UAAUnE,OAAS,IAC3BU,EAAOc,EAAM2C,UACbxD,EAAOa,EAAMb,KACbP,EAAOoB,EAAMpB,KACbQ,EAAYY,EAAMZ,UAClBC,GAAU,EACVC,EAAMU,EAAMV,IAERJ,EAAKV,OAAS,IAGoD,IAAlEU,EAAKR,EAAWU,EAAU,GAAIA,EAAU,GAAIR,IAAO8B,YAEnDxB,EAAKR,EAAWU,EAAU,GAAIA,EAAU,GAAIR,IAAOmC,SAAS,GAI9DvB,EAAEgB,KAAKtB,EAAKR,EAAWU,EAAU,GAAIA,EAAU,GAAIR,KACnDI,EAAaN,EAAWU,EAAU,GAAIA,EAAU,GAAIR,KAIxDE,EAAE8D,KAAF,sBAAS,gCAAAC,EAAA,sDAGP,GAFA/D,EAAEgE,WAAW,IACbhE,EAAEwD,OAAO,IAAK,IAAK,KACN,MAARpD,EAAyB,MAARC,EACpB,IAASZ,EAAI,EAAGA,EAAIW,EAAKV,OAAQD,IAC/BoD,EACEzC,EAAKX,GAAGsC,OACR3B,EAAKX,GAAGuC,OACR5B,EAAKX,GAAGwE,WACR7D,EAAKX,GAAGmC,WACRxB,EAAKX,GAAG6C,aACRjC,GAXC,IAiBS,IAAZE,EAjBG,sBAkBGC,EAlBH,OAmBE,MAnBF,OAsBE,MAtBF,OA2BE,OA3BF,+BAoBDD,EAAUsB,IApBT,mCAwBDtB,EAAU6B,IACVb,QAAQC,IAAIjB,GAzBX,oCA4BDgB,QAAQC,IAAI,QA5BX,oCAgCD0C,MAAM,yBAhCL,gCAoCA3D,EApCA,wBAsCCa,EAAOD,IAtCR,UAuCGf,EAAKF,GAAY+B,SAAS,GAvC7B,QAwCMxC,EAAI,EAxCV,aAwCaA,EAAI2B,EAAK1B,QAxCtB,kCAyCKU,EAAKgB,EAAK3B,IAAIwC,SAAS,GAzC5B,QAwC8BxC,IAxC9B,yCA2CGW,EAAKH,GAAWgC,SAAS,GA3C5B,6C,UCnCEkC,EAVF,SAACjD,GACV,OACI,yBAAKkD,UAAU,iDACX,yBAAKA,UAAU,YAAYC,GAAG,UAC1B,kBAAC,IAAD,CAAW7D,IAAKU,EAAMV,IAAKqD,UAAW3C,EAAM2C,UAAW9D,OAAQA,EAAQM,KAAMa,EAAMoD,IAAKxE,KAAMoB,EAAMpB,KAAMQ,UAAWY,EAAMZ,eCPtHiE,E,WACjB,WAAYzB,EAAGC,GAA+C,IAA5CvD,EAA2C,uDAArC,EAAC,GAAM,GAAM,GAAM,GAAOgF,EAAW,2DACzDC,KAAK3B,EAAIA,EACT2B,KAAK1B,EAAIA,EAET0B,KAAKzB,MAAQxD,EACbiF,KAAKvB,SAAU,EACfuB,KAAKxB,MAAQuB,E,mDAKb,OAAOC,KAAK3B,I,6BAIZ,OAAO2B,KAAK1B,I,iCAIZ,OAAO0B,KAAKzB,Q,2BAEX0B,GACDD,KAAK3B,EAAI4B,I,2BAERA,GACDD,KAAK1B,EAAI2B,I,iCAKT,IAHsC,IAAjClF,EAAgC,uDAA1B,EAAC,GAAM,GAAM,GAAM,GAE1BmF,EAASF,KAAKR,WACTxE,EAAI,EAAGA,EAAIkF,EAAOjF,OAAQD,MACd,IAAdkF,EAAOlF,IAAyB,IAAXD,EAAIC,KAEJ,IAAdkF,EAAOlF,IAA0B,IAAXD,EAAIC,MADhCD,EAAIC,IAAK,GAKjBgF,KAAKzB,MAAQxD,I,mCAGb,OAAOiF,KAAKvB,U,iCAGL0B,GACPH,KAAKvB,QAAU0B,I,iCAGf,OAAOH,KAAKxB,Q,+BAEP2B,GACLH,KAAKxB,MAAQ2B,M,KC9CAC,E,kDACnB,WAAY3D,GAAQ,IAAD,8BACjB,cAAMA,IAgBR4D,iBAAmB,SAACC,GAClB,IAAIC,EAAW,EAAKC,MAAMC,KAAK,EAAKD,MAAMC,KAAKxF,OAAS,GACpDyF,EAAO,EAAKF,MAAMC,KAAK,EAAKD,MAAMC,KAAKxF,OAAS,GAEpDsF,EAAWA,EAASI,MAAM,KAC1BD,EAAOA,EAAKC,MAAM,KAClBJ,EAAWK,EAAyBL,GACpCG,EAAOE,EAAyBF,GAEhCJ,EAASM,EAAiBL,EAAS,GAAIA,EAAS,GAAI,EAAKC,MAAMnF,OAAOmC,SAAS,GAC/E8C,EAASM,EAAiBF,EAAK,GAAIA,EAAK,GAAI,EAAKF,MAAMnF,OAAOmC,SAAS,GACvE,EAAKqD,SAAS,CACZC,QAASP,KA7BM,EAkCnBQ,WAAa,SAACC,GACZ,IAAIC,EAAa,IAAIC,WACrBD,EAAWE,WAAWH,GACtBC,EAAWG,UAAY,SAACC,GACtB,IAAIC,EAAUD,EAAEE,OAAOC,OACvB,EAAKX,SAAS,CACZJ,KAAMa,EAAQX,MAAM,MAEpBc,KAAMH,EAAQI,MAAM,IAAIC,OAAO,KAAM,MAAQ,IAAI1G,OAAS,EAC1DI,KAAMiG,EAAQX,MAAM,MAAM1F,OAAS,MA3CtB,EAoDnB2G,QAAU,SAACP,GACTA,EAAEQ,iBAGF,IAFA,IAAIC,EAAS,GAEJ9G,EAAI,EAAGA,EAAI,EAAKwF,MAAMC,KAAKxF,OAAQD,IACtC+G,MAAM7G,SAAS,EAAKsF,MAAMC,KAAKzF,GAAGgH,OAAO,MAC3CF,EAAO7E,KAAK,EAAKgF,UAAU,EAAKzB,MAAMC,KAAKzF,KAK/C,EAAK6F,SAAS,CACZJ,KAAMqB,IAKR,IAFA,IAAII,EAAS,GAEJlH,EAAI,EAAGA,EAAI,EAAKwF,MAAMiB,KAAMzG,IACnC,IAAK,IAAII,EAAI,EAAGA,EAAI,EAAKoF,MAAMnF,KAAMD,IACnC8G,EAAOjF,KAAK,IAAI6C,EAAK1E,EAAGJ,EAAG,EAAC,GAAO,GAAO,GAAO,GAAQ,IAK7D,IAAK,IAAIA,EAAI,EAAGA,EAAI,EAAKwF,MAAMiB,KAAMzG,IAGnCkH,EAAOtB,EAAiB5F,EAAG,EAAG,EAAKwF,MAAMnF,OAAO8G,SAAS,EAAC,GAAM,GAAO,GAAO,IAC9ED,EAAOtB,EAAiB5F,EAAG,EAAG,EAAKwF,MAAMnF,OAAOmC,SAAS,GAEzD0E,EAAOtB,EAAiB,EAAG5F,EAAG,EAAKwF,MAAMnF,OAAO8G,SAAS,EAAC,GAAO,GAAO,GAAO,IAC/ED,EAAOtB,EAAiB,EAAG5F,EAAG,EAAKwF,MAAMnF,OAAOmC,SAAS,GAEzD0E,EAAOtB,EAAiB5F,EAAG,EAAKwF,MAAMnF,KAAO,EAAG,EAAKmF,MAAMnF,OAAO8G,SAAS,EAAC,GAAO,GAAO,GAAM,IAChGD,EAAOtB,EAAiB5F,EAAG,EAAKwF,MAAMnF,KAAO,EAAG,EAAKmF,MAAMnF,OAAOmC,SAAS,GAE3E0E,EAAOtB,EAAiB,EAAKJ,MAAMiB,KAAO,EAAGzG,EAAG,EAAKwF,MAAMnF,OAAO8G,SAAS,EAAC,GAAO,GAAM,GAAO,IAChGD,EAAOtB,EAAiB,EAAKJ,MAAMiB,KAAO,EAAGzG,EAAG,EAAKwF,MAAMnF,OAAOmC,SAAS,GAM7E,IAAK,IAAIxC,EAAI,EAAGA,EAAI,EAAKwF,MAAMiB,KAAMzG,IACnC,IAAK,IAAII,EAAI,EAAGA,EAAI,EAAKoF,MAAMnF,KAAMD,IACnC,GAA8B,MAA1B,EAAKoF,MAAMC,KAAKzF,GAAGI,GAAY,CACjC,GAAIA,IAAM,EAAKoF,MAAMnF,KAAO,EAC1B,SAEA6G,EAAOtB,EAAiBxF,EAAGJ,EAAG,EAAKwF,MAAMnF,OAAO8G,SAAS,EAAC,GAAO,GAAO,GAAO,IAC/ED,EAAOtB,EAAiBxF,EAAGJ,EAAG,EAAKwF,MAAMnF,OAAOmC,SAAS,OAGxD,IAAIxC,EAAI,EAAI,EAAKwF,MAAMiB,KAC1B,MAEG,GAAkC,MAA9B,EAAKjB,MAAMC,KAAKzF,EAAI,GAAGI,GAA2C,MAA9B,EAAKoF,MAAMC,KAAKzF,EAAI,GAAGI,GAAuC,MAA1B,EAAKoF,MAAMC,KAAKzF,GAAGI,GAAY,CAE9G,GAAIA,IAAM,EAAKoF,MAAMnF,KAAO,EAC1B,SAEA6G,EAAOtB,EAAiBxF,EAAGJ,EAAG,EAAKwF,MAAMnF,OAAO8G,SAAS,EAAC,GAAO,GAAO,GAAO,IAC/ED,EAAOtB,EAAiBxF,EAAGJ,EAAG,EAAKwF,MAAMnF,OAAOmC,SAAS,IAOjE,IAAK,IAAIxC,EAAI,EAAGA,EAAI,EAAKwF,MAAMiB,KAAMzG,IACnC,IAAK,IAAII,EAAI,EAAGA,EAAI,EAAKoF,MAAMnF,KAAMD,IACL,MAA1B,EAAKoF,MAAMC,KAAKzF,GAAGI,KACrB8G,EAAOtB,EAAiBxF,EAAGJ,EAAG,EAAKwF,MAAMnF,OAAO8G,SAAS,EAAC,GAAO,GAAO,GAAM,IAC9ED,EAAOtB,EAAiBxF,EAAGJ,EAAG,EAAKwF,MAAMnF,OAAOmC,SAAS,IAEzB,MAA9B,EAAKgD,MAAMC,KAAKzF,GAAGI,EAAI,IAA4C,MAA9B,EAAKoF,MAAMC,KAAKzF,GAAGI,EAAI,IAAwC,MAA1B,EAAKoF,MAAMC,KAAKzF,GAAGI,KAC/F8G,EAAOtB,EAAiBxF,EAAGJ,EAAG,EAAKwF,MAAMnF,OAAO8G,SAAS,EAAC,GAAO,GAAO,GAAM,IAC9ED,EAAOtB,EAAiBxF,EAAGJ,EAAG,EAAKwF,MAAMnF,OAAOmC,SAAS,IAI/D,EAAK6C,iBAAiB6B,GACtB,EAAKrB,SAAS,CACZlF,KAAMuG,IAGR,EAAKE,gBAEL3C,MAAM,wIACN,EAAKoB,SAAW,CACdlF,KAAM,GACNN,KAAM,EACNoG,KAAM,EACNY,SAAU,EACV5B,KAAM,GACNK,QAAS,GACTwB,UAAW,OApJI,EA0JnBF,cAAgB,WAAkB,IAAjBG,EAAgB,uDAAR,IACvB,EAAK1B,SAAS,CACZwB,SAAUzD,KAAKC,MAAM0D,EAAQ,EAAK/B,MAAMnF,MAAQ,KA5JjC,EAkKnB4G,UAAY,SAACO,GAGX,IAFA,IAAIxH,EAAI,EACJyH,EAAW,GACU,KAAlBD,EAAIR,OAAOhH,IAChByH,EAASxF,KAAKuF,EAAIR,OAAOhH,IACzBA,IAGF,OAAOyH,GAxKP,EAAKjC,MAAQ,CACX7E,KAAM,GACNN,KAAM,EACNoG,KAAM,EACNY,SAAU,EACV5B,KAAM,GACNK,QAAS,GACTwB,UAAW,MATI,E,qDA6KT,IAAD,OACP,OACE,yBAAK3C,UAAU,OACb,yBAAKA,UAAU,mBACb,yBAAKA,UAAU,sDACb,yBAAKA,UAAU,aACb,wBAAIA,UAAU,SAAd,gBACA,0BAAMC,GAAG,QACP,yBAAKD,UAAU,eACb,2BAAO+C,KAAK,OAAOC,OAAO,OAAOhD,UAAU,oBAAoBC,GAAG,aAChEgD,SAAU,SAAAvB,GAAC,OAAI,EAAKN,WAAWM,EAAEE,OAAOsB,MAAM,OAChD,2BAAOlD,UAAU,oBAAoBmD,QAAQ,cAA7C,gBAEF,wBAAInD,UAAU,OAAd,0CACA,2BAAOA,UAAU,gBACf,2BAAOiD,SAAU,SAAAvB,GAAC,OAAI,EAAKR,SAAS,CAAEyB,UAAWjB,EAAEE,OAAO/C,SAAUkE,KAAK,QAAQK,KAAK,SAASnD,GAAG,UAAUpB,MAAO,IADrH,OAIA,2BAAOmB,UAAU,gBACf,2BAAOiD,SAAU,SAAAvB,GAAC,OAAI,EAAKR,SAAS,CAAEyB,UAAWjB,EAAEE,OAAO/C,SAAUkE,KAAK,QAAQK,KAAK,SAASnD,GAAG,UAAUpB,MAAO,IADrH,OAIA,6BAC0B,OAAzBwB,KAAKQ,MAAM8B,UAAyC,IAApBtC,KAAKQ,MAAMiB,KAC1C,4BAAQiB,KAAK,SAAS9C,GAAG,SAASD,UAAU,kBAAkBqD,UAAQ,EAACC,QAASjD,KAAK4B,SAArF,UACA,4BAAQc,KAAK,SAAS9C,GAAG,SAASD,UAAU,kBAAkBsD,QAASjD,KAAK4B,SAA5E,WAEJ,kBAAC,EAAD,CAAMsB,SAAUlD,KAAKQ,MAAM2C,WAAY/D,UAAWY,KAAKQ,MAAM7E,KAAMkE,IAAKG,KAAKQ,MAAM6B,SAAUhH,KAAM2E,KAAKQ,MAAMnF,KAAMQ,UAAWmE,KAAKQ,MAAMM,QAAS/E,IAAKiE,KAAKQ,MAAM8B,oB,GAzMhJc,IAAMC,WCDvCC,IAASC,OACP,kBAAC,IAAMC,WAAP,KACE,kBAAC,EAAD,OAEFC,SAASC,eAAe,W","file":"static/js/main.0469c77d.chunk.js","sourcesContent":["\n/*\nexpects an array containing numbers that are formatted as string.\nreturns transformed numbers ['0', '0'] -> [1, 1]\nelse ['1', '2'] -> [2, 4]\n*/\nexport function transformLocations(arr) {\n    for (let i = 0; i < arr.length; i++) {\n        arr[i] = parseInt(arr[i])\n        if (arr[i] === 0) {\n            arr[i] = 1\n        } else {\n            arr[i] = (arr[i] * 2) + 1\n        }\n    }\n    return arr\n}\n/**\n * Provided an orderly pushed cells from row and column it will find the position in a 1D maze given 2D coordinates\n * @param {*} i \n * @param {*} j \n * @param {*} cols \n */\nexport function indexTrans(i, j, cols){\n    return i + j * (cols);\n  }","import { indexTrans } from \"./functions\";\n//variables for path backtrack tracing\n\nexport default function sketch(p) {\n  let grid = null;\n  let size = null;\n  let mazeStart = [];\n  let cols;\n  let execute = false;\n  let alg = null;\n\n  let map = {};\n  let lastPoint;\n  let startPoint;\n\n  let index;\n  let q = [];\n  let cell = undefined;\n\n  //setup of maze with null values.\n  p.setup = () => {\n    var myCanvas = p.createCanvas(600, 600);\n    myCanvas.parent(\"canvas\");\n    p.frameRate(120);\n  };\n  //This is called when props are updated.\n  p.myCustomRedrawAccordingToNewPropsHandler = (props) => {\n    if (props.codedMaze.length > 0) {\n      grid = props.codedMaze;\n      size = props.size;\n      cols = props.cols;\n      mazeStart = props.mazeStart;\n      execute = true;\n      alg = props.alg;\n\n      if (grid.length > 0) {\n        // Set the start point\n        if (\n          grid[indexTrans(mazeStart[0], mazeStart[1], cols)].getValue() !== 9\n        ) {\n          grid[indexTrans(mazeStart[0], mazeStart[1], cols)].setValue(3);\n        }\n\n        // Add the start point to queue\n        q.push(grid[indexTrans(mazeStart[0], mazeStart[1], cols)]);\n        startPoint = indexTrans(mazeStart[0], mazeStart[1], cols);\n      }\n    }\n\n    p.draw = async () => {\n      p.background(51);\n      p.stroke(255, 255, 255);\n      if ((grid != null) & (size != null)) {\n        for (var i = 0; i < grid.length; i++) {\n          show(\n            grid[i].getX(),\n            grid[i].getY(),\n            grid[i].getWalls(),\n            grid[i].getValue(),\n            grid[i].getVisited(),\n            size\n          );\n        }\n      }\n\n      //decides which algorithm we will use\n      if (execute === true) {\n        switch (alg) {\n          case \"1\":\n            execute = bfs();\n            break;\n          case \"2\":\n            \n            execute = dfs();\n            console.log(execute)\n            break;\n          case null:\n            console.log(\"pass\");\n            break;\n\n          default:\n            alert(\"This is a major error\");\n            break;\n        }\n        //draw path\n        if (!execute) {\n        \n          let path = makePath();\n          await grid[startPoint].setValue(3);\n          for (let i = 0; i < path.length; i++) {\n            await grid[path[i]].setValue(9);\n          }\n          await grid[lastPoint].setValue(3);\n\n        }\n      }\n    };\n    /**\n     * Function that provided as key the parent cell will return the child cells, used to backtrack original position.\n     */\n    function makePath() {\n      let path = [];\n      let crr = lastPoint;\n\n      while (crr !== startPoint) {\n        console.log(\"Current value:\", crr)\n        for (let key in map) {\n          if (map[parseInt(key)].includes(crr)) {\n            path.push(crr);\n            crr = parseInt(key);\n          }\n        }\n      }\n      return path;\n    }\n    /**\n     * Used by BFS to determine whether it can be visited or not.\n     * @param {*} i -> x\n     * @param {*} j  -> y\n     */\n    function isFree(i, j) {\n      if (\n        (i >= 0) &\n        (i < grid.length) &\n        (j >= 0) &\n        (j < grid.length) &\n        ((grid[indexTrans(i, j, cols)].getValue() === 0) |\n          (grid[indexTrans(i, j, cols)].getValue() === 9))\n      ) {\n        return true;\n      }\n\n      return false;\n    }\n    /**\n     * Provided the encoded 1D array of cells it will traverse it via BFS method\n     *\n     */\n    function bfs() {\n      cell = q.shift();\n      index = indexTrans(cell.getX(), cell.getY(), cols);\n\n      if (grid[indexTrans(cell.getX(), cell.getY(), cols)].getValue() === 2) {\n\n        return true;\n      }\n\n      map[index] = [];\n\n      if (grid[indexTrans(cell.getX(), cell.getY(), cols)].getValue() === 9) {\n        console.log(\"Finish!!!\");\n        lastPoint = indexTrans(cell.getX(), cell.getY(), cols);\n        return false;\n      }\n\n      grid[indexTrans(cell.getX(), cell.getY(), cols)].setValue(2);\n      grid[indexTrans(cell.getX(), cell.getY(), cols)].setVisited(true);\n\n      //Right neighbor\n      if (isFree(cell.getX() + 1, cell.getY()) === true) {\n        let next = grid[indexTrans(cell.getX() + 1, cell.getY(), cols)];\n        map[index].push(indexTrans(cell.getX() + 1, cell.getY(), cols));\n        q.push(next);\n      }\n      //Left neighbor\n      if (isFree(cell.getX() - 1, cell.getY()) === true) {\n        let next = grid[indexTrans(cell.getX() - 1, cell.getY(), cols)];\n        map[index].push(indexTrans(cell.getX() - 1, cell.getY(), cols));\n        q.push(next);\n      }\n      //Down neighbor\n      if (isFree(cell.getX(), cell.getY() + 1) === true) {\n        let next = grid[indexTrans(cell.getX(), cell.getY() + 1, cols)];\n        map[index].push(indexTrans(cell.getX(), cell.getY() + 1, cols));\n        q.push(next);\n      }\n      //Up neighbor\n      if (isFree(cell.getX(), cell.getY() - 1) === true) {\n        let next = grid[indexTrans(cell.getX(), cell.getY() - 1, cols)];\n        map[index].push(indexTrans(cell.getX(), cell.getY() - 1, cols));\n        q.push(next);\n      }\n\n      return true;\n    }\n\n    /**\n     * Provided the encoded 1D array of cells it will traverse it via DFS method\n     *\n     */\n    function dfs() {\n      \n      if (grid[indexTrans(mazeStart[0], mazeStart[1], cols)].getValue() !== 9) {\n        grid[indexTrans(mazeStart[0], mazeStart[1], cols)].setValue(2);\n        grid[indexTrans(mazeStart[0], mazeStart[1], cols)].setVisited(true);\n      }\n      //we set starting point\n      cell = q.pop();\n      //set variables to recreate path..\n      if (grid[indexTrans(cell.getX(), cell.getY(), cols)].getValue() === 9) {\n        console.log(\"Finish!!!\");\n        lastPoint = indexTrans(cell.getX(), cell.getY(), cols);\n        startPoint = indexTrans(mazeStart[0], mazeStart[1], cols);\n        return false;\n      }\n\n      //recreate map\n      index = indexTrans(cell.getX(), cell.getY(), cols);\n      \n\n      console.log(q)\n      map[index] = [];\n\n      if ((cell.getValue() !== 2) | !cell.getVisited()) {\n        cell.setValue(2);\n        cell.setVisited(true);\n      }\n      let neighbors = [];\n      //we add cell neighbors\n      if (isFree(cell.getX() + 1, cell.getY()) === true) {\n        let neighborR =  grid[\n          indexTrans(cell.getX() + 1, cell.getY(), cols)\n        ];\n        map[index].push(indexTrans(cell.getX() + 1, cell.getY(), cols));\n        neighbors.push(neighborR);\n      }\n      if (isFree(cell.getX() - 1, cell.getY()) === true) {\n        let neighborL =  grid[\n          indexTrans(cell.getX() - 1, cell.getY(), cols)\n        ];\n        map[index].push(indexTrans(cell.getX() - 1, cell.getY(), cols));\n\n        neighbors.push(neighborL);\n      }\n      if (isFree(cell.getX(), cell.getY() + 1) === true) {\n        let neighborD =  grid[\n          indexTrans(cell.getX(), cell.getY() + 1, cols)\n        ];\n        map[index].push(indexTrans(cell.getX(), cell.getY() + 1, cols));\n\n        neighbors.push(neighborD);\n      }\n      if (isFree(cell.getX(), cell.getY() - 1) === true) {\n        let neighborU = grid[\n          indexTrans(cell.getX(), cell.getY() - 1, cols)\n        ];\n        map[index].push(indexTrans(cell.getX(), cell.getY() - 1, cols));\n\n        neighbors.push(neighborU);\n      }\n\n      for (let i = 0; i < neighbors.length; i++) {\n        let cellNeighbor = neighbors[i];\n        if (\n          cellNeighbor &&\n          !cellNeighbor.getVisited() &&\n          cellNeighbor.getValue() !== 2\n        ) {\n          console.log(cellNeighbor)\n          q.push(cellNeighbor);\n        }\n      }\n      return true\n    }\n    /**\n     * Function that reads the state of each individual cell in the map. Code inspired by https://www.youtube.com/watch?v=HyK_Q5rrcr4\n     *\n     * @param {*} x\n     * @param {*} y\n     * @param {*} walls\n     * @param {*} value\n     * @param {*} visited\n     * @param {*} size\n     */\n    function show(\n      x,\n      y,\n      walls = [true, true, true, true],\n      value,\n      visited,\n      size\n    ) {\n      const w = size;\n      var coord_x = Math.floor((x + 1) * w);\n      var coord_y = Math.floor((y + 1) * w);\n      if (visited === true) {\n        p.stroke(255, 0, 255, 100);\n        p.fill(255, 0, 255, 100);\n        p.rect(coord_x, coord_y, w, w);\n        p.stroke(255, 255, 255);\n      }\n      switch (value) {\n        //salida\n        case 9:\n          p.stroke(255, 0, 100);\n          p.fill(255, 0, 100);\n          p.rect(coord_x, coord_y, w, w);\n          p.stroke(255, 255, 255);\n          break;\n        //entrada\n        case 3:\n          p.stroke(14, 239, 21);\n          p.fill(14, 239, 21);\n          p.rect(coord_x, coord_y, w, w);\n          p.stroke(255, 255, 255);\n          break;\n        default:\n          p.stroke(255, 255, 255);\n          p.noFill();\n          break;\n      }\n\n      if (walls[0]) {\n        //top\n        p.line(coord_x, coord_y, coord_x + w, coord_y);\n      }\n\n      if (walls[1]) {\n        //right\n        p.line(coord_x + w, coord_y, coord_x + w, coord_y + w);\n      }\n\n      if (walls[2]) {\n        //bottom\n        p.line(coord_x, coord_y + w, coord_x + w, coord_y + w);\n      }\n\n      if (walls[3]) {\n        //left\n        p.line(coord_x, coord_y + w, coord_x, coord_y);\n      }\n    }\n  };\n}\n","import React from 'react';\nimport P5Wrapper from 'react-p5-wrapper';\nimport sketch from '../Utils & Objects/sketch.js'\nimport '../CSS/Maze.css'\nconst Maze = (props) => {\n    return (\n        <div className=\"row justify-content-center align-items-center\">\n            <div className=\".col-xl-1\" id=\"canvas\">\n                <P5Wrapper alg={props.alg} codedMaze={props.codedMaze} sketch={sketch} size={props.dim} cols={props.cols} mazeStart={props.mazeStart} />\n            </div>\n        </div>\n    )\n}\n\nexport default Maze","\nexport default class Cell {\n    constructor(x, y, arr = [true, true, true, true], mazeValue) {\n        this.x = x;\n        this.y = y;\n        // top, right, bottom, left\n        this.walls = arr\n        this.visited = false\n        this.value = mazeValue\n\n    }\n\n    getX() {\n        return this.x\n    }\n\n    getY() {\n        return this.y\n    }\n\n    getWalls() {\n        return this.walls\n    }\n    setX(adjust) {\n        this.x = adjust\n    }\n    setY(adjust) {\n        this.y = adjust\n    }\n    setWalls(arr = [true, true, true, true]) {\n        //this will avoid override of previously defined walls.\n        let oldArr = this.getWalls()\n        for (let i = 0; i < oldArr.length; i++) {\n            if(oldArr[i] === true & arr[i] === false){\n                arr[i] = true\n            } else if(oldArr[i] === false & arr[i] === true){\n                arr[i] = true\n            }\n        }\n        this.walls = arr\n    }\n    getVisited(){\n        return this.visited\n    }\n\n    setVisited(val){\n        this.visited = val\n    }\n    getValue(){\n        return this.value\n    }\n    setValue(val){\n        this.value = val\n    }\n\n}","import React from 'react';\nimport 'bootstrap/dist/css/bootstrap.min.css';\nimport '../CSS/App.css';\nimport Maze from './Maze.js'\nimport Cell from '../Utils & Objects/Cell.js'\nimport * as utils from '../Utils & Objects/functions.js'\nexport default class App extends React.Component {\n  constructor(props) {\n    super(props)\n    this.state = {\n      grid: [],\n      cols: 0,\n      rows: 0,\n      sizeCell: 0,\n      text: \"\",\n      special: [],\n      algorithm: null\n    }\n  }\n\n  /**\n   * Method used to find the exit and entrance, it looks in the param the last 2 lines,\n   * splits them to get the values of coordinates, and transforms such coordinates into our local coordinate system\n   */\n  identifySpecials = (paramArr) => {\n    let entrance = this.state.text[this.state.text.length - 2]\n    let exit = this.state.text[this.state.text.length - 1]\n    //we need to split..\n    entrance = entrance.split(',')\n    exit = exit.split(',')\n    entrance = utils.transformLocations(entrance)\n    exit = utils.transformLocations(exit)\n    //change values of real matrix\n    paramArr[utils.indexTrans(entrance[0], entrance[1], this.state.cols)].setValue(3)\n    paramArr[utils.indexTrans(exit[1], exit[0], this.state.cols)].setValue(9)\n    this.setState({\n      special: entrance\n    })\n\n  }\n\n  handleFile = (file) => {\n    var fileReader = new FileReader()\n    fileReader.readAsText(file)\n    fileReader.onloadend = (e) => {\n      var content = e.target.result\n      this.setState({\n        text: content.split(\"\\n\"),\n        // eslint-disable-next-line\n        rows: content.match(new RegExp(\"\\n\", \"g\") || []).length - 1,\n        cols: content.split('\\n').length - 2 //count from 0.\n      })\n    }\n\n  }\n  i\n  /**\n   * Method called onSubmit. This will set all the variables needed to render the map.\n   */\n  addFile = (e) => {\n    e.preventDefault()\n    let tmpArr = []\n\n    for (let i = 0; i < this.state.text.length; i++) {\n      if (isNaN(parseInt(this.state.text[i].charAt(0)))) {\n        tmpArr.push(this.linetoArr(this.state.text[i]))\n      }\n    }\n\n    //we have the 2d arr of chars.\n    this.setState({\n      text: tmpArr\n    })\n\n    var tmpMap = []\n    //load the map of cell objects\n    for (let i = 0; i < this.state.rows; i++) {\n      for (let j = 0; j < this.state.cols; j++) {\n        tmpMap.push(new Cell(j, i, [false, false, false, false], 0))\n      }\n    }\n\n    //external walls\n    for (let i = 0; i < this.state.rows; i++) {\n\n      //top border\n      tmpMap[utils.indexTrans(i, 0, this.state.cols)].setWalls([true, false, false, false])\n      tmpMap[utils.indexTrans(i, 0, this.state.cols)].setValue(1)\n      //left border\n      tmpMap[utils.indexTrans(0, i, this.state.cols)].setWalls([false, false, false, true])\n      tmpMap[utils.indexTrans(0, i, this.state.cols)].setValue(1)\n      //down\n      tmpMap[utils.indexTrans(i, this.state.cols - 1, this.state.cols)].setWalls([false, false, true, false])\n      tmpMap[utils.indexTrans(i, this.state.cols - 1, this.state.cols)].setValue(1)\n      // right border\n      tmpMap[utils.indexTrans(this.state.rows - 1, i, this.state.cols)].setWalls([false, true, false, false])\n      tmpMap[utils.indexTrans(this.state.rows - 1, i, this.state.cols)].setValue(1)\n\n\n    }\n\n    //Lets set internal walls\n    for (let i = 1; i < this.state.rows; i++) {\n      for (let j = 1; j < this.state.cols; j++) {\n        if (this.state.text[i][j] === '|') {\n          if (j === this.state.cols - 1) {\n            continue\n          } else {\n            tmpMap[utils.indexTrans(j, i, this.state.cols)].setWalls([false, false, false, true])\n            tmpMap[utils.indexTrans(j, i, this.state.cols)].setValue(1)\n          }\n        }\n        else if (i + 1 > this.state.rows) {\n          break;\n        }\n        else if (this.state.text[i - 1][j] === '|' & this.state.text[i + 1][j] === '|' & this.state.text[i][j] === ' ') {\n          //we dont want to alter the borders\n          if (j === this.state.cols - 1) {\n            continue\n          } else {\n            tmpMap[utils.indexTrans(j, i, this.state.cols)].setWalls([false, false, false, true])\n            tmpMap[utils.indexTrans(j, i, this.state.cols)].setValue(1)\n          }\n        }\n\n      }\n    }\n    //decide whether we need column or wall\n    for (let i = 1; i < this.state.rows; i++) {\n      for (let j = 1; j < this.state.cols; j++) {\n        if (this.state.text[i][j] === '-') {\n          tmpMap[utils.indexTrans(j, i, this.state.cols)].setWalls([false, false, true, false])\n          tmpMap[utils.indexTrans(j, i, this.state.cols)].setValue(1)\n        }\n        if (this.state.text[i][j - 1] === '-' && this.state.text[i][j + 1] === '-' && this.state.text[i][j] === ' ') {\n          tmpMap[utils.indexTrans(j, i, this.state.cols)].setWalls([false, false, true, false])\n          tmpMap[utils.indexTrans(j, i, this.state.cols)].setValue(1)\n        }\n      }\n    }\n    this.identifySpecials(tmpMap)\n    this.setState({\n      grid: tmpMap\n    })\n\n    this.calculateDims()\n\n    alert(\"When the path is shown, please reload the site to solve the maze again.\\n \\t Thanks to Hayri Yigit for assistance during the project\")\n    this.setState = {\n      grid: [],\n      cols: 0,\n      rows: 0,\n      sizeCell: 0,\n      text: \"\",\n      special: [],\n      algorithm: null\n    }\n  }\n  /**\n   * calculates size of cell depending on the width and height of the map.\n   */\n  calculateDims = (width = 600) => {\n    this.setState({\n      sizeCell: Math.floor(width / this.state.cols) - 3\n    })\n  }\n  /**\n   * Receives a string and iterates through it, and returns array of chars.\n   */\n  linetoArr = (str) => {\n    let i = 0\n    let char_arr = []\n    while (str.charAt(i) !== \"\") {\n      char_arr.push(str.charAt(i))\n      i++\n\n    }\n    return char_arr\n  }\n\n  render() {\n    return (\n      <div className=\"App\">\n        <div className=\"container h-100\">\n          <div className=\"row mt-4 justify-content-center align-items-center\">\n            <div className=\".col-xl-1\">\n              <h2 className=\"title\">Maze Solver!</h2>\n              <form id=\"form\">\n                <div className=\"custom-file\">\n                  <input type=\"file\" accept='.txt' className=\"custom-file-input\" id=\"customFile\"\n                    onChange={e => this.handleFile(e.target.files[0])} />\n                  <label className=\"custom-file-label\" htmlFor=\"customFile\">Choose file</label>\n                </div>\n                <h5 className=\"sub\">Select the algorithm to solve the maze</h5>\n                <label className=\"radio-inline\">\n                  <input onChange={e => this.setState({ algorithm: e.target.value })} type=\"radio\" name=\"survey\" id=\"Radios1\" value={1} />\n                    BFS\n                </label>\n                <label className=\"radio-inline\">\n                  <input onChange={e => this.setState({ algorithm: e.target.value })} type=\"radio\" name=\"survey\" id=\"Radios2\" value={2} />\n                      DFS\n                </label>\n                <br></br>\n                {this.state.algorithm === null | this.state.rows === 0 ?\n                  <button type=\"submit\" id=\"submit\" className=\"btn btn-primary\" disabled onClick={this.addFile}>Submit</button> :\n                  <button type=\"submit\" id=\"submit\" className=\"btn btn-primary\" onClick={this.addFile}>Submit</button>}\n              </form>\n              <Maze mazeGrid={this.state.actualMaze} codedMaze={this.state.grid} dim={this.state.sizeCell} cols={this.state.cols} mazeStart={this.state.special} alg={this.state.algorithm} />\n            </div>\n          </div>\n        </div>\n\n      </div>\n    );\n  }\n\n}\n\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './CSS/index.css';\nimport App from './Components/App';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n"],"sourceRoot":""}